<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stingray Accessory Manufacturers â€“ Smooth Staggered Hover</title>

 

  <style>
    :root {
      --base-font: 'Poppins', system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
      --font-1: 'Poppins', sans-serif;        /* Base look */
      --font-2: 'Oswald', sans-serif;         /* Strong condensed */
      --font-3: 'Merriweather', serif;        /* Classic serif */
      --font-4: 'Fira Code', monospace;       /* Monospace pop */

      --txt: #0f172a;
      --accent: #0ea5e9;

      /* Smooth, slight bounce easing */
      --trans-dur: 100ms;
      --ease: cubic-bezier(.45, 1.15, .5, 1);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      background: #ffffff;
      color: var(--txt);
      font-family: var(--base-font);
      padding: 24px;
    }

    h1 {
      font-family: var(--font-1);
      font-size: clamp(28px, 6vw, 85px);
      line-height: 1.15;
      font-weight: 700;
      letter-spacing: 0.015em;
      margin: 0;
      user-select: none;
      -webkit-user-select: none;
    }

    /* Each letter gets its own span so hover works per-letter */
    .letter {
      display: inline-block;
      position: relative;
      cursor: default;
      /* Eased feedback; font-family flips are discrete but visuals are smooth */
      transition: transform var(--trans-dur) var(--ease), color var(--trans-dur) var(--ease);
      will-change: transform; /* hint for smoother frames */
    }

    /* Hover feedback (smooth, slight bounce) */
    .letter:hover {
      transform: translateY(-1px) scale(1.02);
      color: var(--accent);
    }

    /* Group-burst visual feedback */
    .letter.burst {
      transform: translateY(-1px) scale(1.02);
      color: var(--accent);
    }

    /* Preserve spacing for spaces */
    .letter.space { width: 0.4em; }

    /* Reduced motion: keep instant font flip, no animated feedback */
    @media (prefers-reduced-motion: reduce) {
      .letter { transition: none; }
      .letter:hover { color: inherit; transform: none; }
      .letter.burst { color: inherit; transform: none; }
    }
  </style>
</head>
<body>
  <h1 id="heading">Stingray Accessory Manufacturers</h1>

  <script>
    (function () {
      const heading = document.getElementById('heading');

      const fonts = [
        'var(--font-1)', // Poppins
        'var(--font-2)', // Oswald
        'var(--font-3)', // Merriweather
        'var(--font-4)'  // Fira Code
      ];

      const intervalMs       = 300; // per-letter cycling speed while hovered
      const resetDelayMs     = 50; // small delay so scans feel lively
      const groupResetDelay  = 200; // how long burst flip stays
      const staggerMs        = 50;  // stagger for wave (close to 60fps frame time)

      // Split into spans per letter
      function wrapLetters(el) {
        const text = el.textContent;
        el.textContent = '';
        const frag = document.createDocumentFragment();
        for (const ch of text) {
          const span = document.createElement('span');
          span.className = 'letter';
          if (ch === ' ') {
            span.classList.add('space');
            span.textContent = '\u00A0';
          } else {
            span.textContent = ch;
          }
          frag.appendChild(span);
        }
        el.appendChild(frag);
      }

      wrapLetters(heading);

      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // Build per-letter state list
      const letters = Array.from(heading.querySelectorAll('.letter'));
      const states = letters.map(el => ({
        el,
        step: 0,
        hovered: false,
        lastSwitch: 0,
        resetAt: null,
        burstAt: null,
        burstActive: false,
        burstResetAt: null
      }));

      function bump(state, t) {
        state.step = (state.step + 1) % fonts.length;
        state.el.style.fontFamily = fonts[state.step];
        state.lastSwitch = t;
      }

      function onLetterEnter(e) {
        const idx = letters.indexOf(e.currentTarget);
        const s = states[idx];
        s.hovered = true;
        s.resetAt = null;
        s.burstResetAt = null;
        s.el.classList.remove('burst');
        // Immediate flip for responsiveness
        bump(s, performance.now());
      }

      function onLetterLeave(e) {
        const idx = letters.indexOf(e.currentTarget);
        const s = states[idx];
        s.hovered = false;
        // Schedule a quick reset to base font (handled in rAF)
        s.resetAt = performance.now() + resetDelayMs;
      }

      letters.forEach(el => {
        el.addEventListener('pointerenter', onLetterEnter);
        el.addEventListener('pointerleave', onLetterLeave);
        // Mouse fallback (for older browsers/devices)
        el.addEventListener('mouseenter', onLetterEnter);
        el.addEventListener('mouseleave', onLetterLeave);
      });

      function groupBurst() {
        const now = performance.now();
        states.forEach((s, i) => {
          // Stagger the burst along the line
          s.burstAt = now + i * staggerMs;
        });
      }

      function clearAll() {
        // On leaving the heading entirely, reset everything cleanly
        states.forEach(s => {
          s.hovered = false;
          s.resetAt = null;
          s.burstAt = null;
          s.burstActive = false;
          s.burstResetAt = null;
          s.el.classList.remove('burst');
          s.el.style.fontFamily = '';
        });
      }

      heading.addEventListener('pointerenter', groupBurst);
      heading.addEventListener('mouseenter', groupBurst);
      heading.addEventListener('pointerleave', clearAll);
      heading.addEventListener('mouseleave', clearAll);

      // Single rAF loop for smooth, frame-synced updates
      function tick(t) {
        for (const s of states) {
          // Handle hovered cycling synced to 150ms cadence
          if (s.hovered && !prefersReduced) {
            if (t - s.lastSwitch >= intervalMs) {
              bump(s, t);
            }
          }

          // Handle quick reset after leaving a letter
          if (!s.hovered && s.resetAt && t >= s.resetAt) {
            s.el.style.fontFamily = '';
            s.resetAt = null;
          }

          // Handle staggered group burst
          if (!s.hovered && s.burstAt && t >= s.burstAt) {
            bump(s, t);
            s.el.classList.add('burst');
            s.burstActive = true;
            s.burstResetAt = t + groupResetDelay;
            s.burstAt = null; // consumed
          }

          // Reset after burst unless letter has since been hovered
          if (!s.hovered && s.burstActive && s.burstResetAt && t >= s.burstResetAt) {
            s.el.classList.remove('burst');
            s.el.style.fontFamily = '';
            s.burstActive = false;
            s.burstResetAt = null;
          }
        }
        requestAnimationFrame(tick);
      }

      requestAnimationFrame(tick);
    })();
  </script>
</body>
</html>